(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{1075:function(e,t,n){"use strict";n.r(t),t.default={placeholder:"InfiniteListDocExampleCommon-module__placeholder___1F6cs","item-content":"InfiniteListDocExampleCommon-module__item-content___1EwQg","main-content":"InfiniteListDocExampleCommon-module__main-content___3YhfB"}},1100:function(e,t,n){"use strict";var i=n(6);Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var a=i(n(0)),u=i(n(5)),c=i(n(1075)),l=u.default.bind(c.default),r=function(e){var t=e.children;return a.default.createElement("div",{className:l("main-content")},t)};t.default=r},1114:function(e,t,n){"use strict";n.d(t,"a",(function(){return l}));var i=n(0),a=n.n(i),u=n(989),c=n.n(u),l=function(e){var t=e.url;return a.a.createElement(c.a,{src:"https://github.com/cerner/terra-framework/tree/main/packages/terra-infinite-list",name:"terra-infinite-list",version:"3.39.0",url:t})}},1662:function(e,t,n){"use strict";var i=n(6),a=n(12);Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var u=i(n(0)),c=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!==a(e)&&"function"!=typeof e)return{default:e};var n=m(t);if(n&&n.has(e))return n.get(e);var i={},u=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var c in e)if("default"!==c&&Object.prototype.hasOwnProperty.call(e,c)){var l=u?Object.getOwnPropertyDescriptor(e,c):null;l&&(l.get||l.set)?Object.defineProperty(i,c,l):i[c]=e[c]}i.default=e,n&&n.set(e,i);return i}(n(344)),l=n(1028),r=i(n(5)),o=i(n(1663)),s=i(n(1100)),d=i(n(1075));function m(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(m=function(e){return e?n:t})(e)}var p=r.default.bind(d.default),f=function(e){var t=[u.default.createElement(c.SubsectionHeader,{key:e.key,title:e.title})];return e.childItems.forEach((function(e){return t.push((n=e,u.default.createElement(c.Item,{key:n.key},u.default.createElement(l.Placeholder,{title:n.title,className:p("placeholder")}))));var n})),t},y=function(e){return e.map((function(e){return function(e){var t=[u.default.createElement(c.SectionHeader,{key:e.key,title:e.title})];return e.childItems.forEach((function(e){return t.push(f(e))})),t}(e)}))},b=function(){return u.default.createElement(s.default,null,u.default.createElement(c.default,{dividerStyle:"standard",isFinishedLoading:!0,ariaLabel:"Subsection"},y(o.default)))};t.default=b},1663:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=[{title:"Section 0",key:"unique-key-0",childItems:[{title:"Subsection 0-0",key:"unique-key-0-0",childItems:[{title:"Item 0-0-0",key:"unique-0-0-0"},{title:"Item 0-0-1",key:"unique-0-0-1"},{title:"Item 0-0-2",key:"unique-0-0-2"},{title:"Item 0-0-3",key:"unique-0-0-3"},{title:"Item 0-0-4",key:"unique-0-0-4"},{title:"Item 0-0-5",key:"unique-0-0-5"}]},{title:"Subsection 0-1",key:"unique-key-0-1",childItems:[{title:"Item 0-1-0",key:"unique-0-1-0"},{title:"Item 0-1-1",key:"unique-0-1-1"},{title:"Item 0-1-2",key:"unique-0-1-2"},{title:"Item 0-1-3",key:"unique-0-1-3"},{title:"Item 0-1-4",key:"unique-0-1-4"},{title:"Item 0-1-5",key:"unique-0-1-5"}]}]},{title:"Section 1",key:"unique-key-1",childItems:[{title:"Subsection 1-0",key:"unique-key-1-0",childItems:[{title:"Item 1-0-0",key:"unique-1-0-0"},{title:"Item 1-0-1",key:"unique-1-0-1"},{title:"Item 1-0-2",key:"unique-1-0-2"},{title:"Item 1-0-3",key:"unique-1-0-3"},{title:"Item 1-0-4",key:"unique-1-0-4"},{title:"Item 1-0-5",key:"unique-1-0-5"}]},{title:"Subsection 1-1",key:"unique-key-1-1",childItems:[{title:"Item 1-1-0",key:"unique-1-1-0"},{title:"Item 1-1-1",key:"unique-1-1-1"},{title:"Item 1-1-2",key:"unique-1-1-2"},{title:"Item 1-1-3",key:"unique-1-1-3"},{title:"Item 1-1-4",key:"unique-1-1-4"},{title:"Item 1-1-5",key:"unique-1-1-5"}]}]},{title:"Section 2",key:"unique-key-2",childItems:[{title:"Subsection 2-0",key:"unique-key-2-0",childItems:[{title:"Item 2-0-0",key:"unique-2-0-0"},{title:"Item 2-0-1",key:"unique-2-0-1"},{title:"Item 2-0-2",key:"unique-2-0-2"},{title:"Item 2-0-3",key:"unique-2-0-3"},{title:"Item 2-0-4",key:"unique-2-0-4"},{title:"Item 2-0-5",key:"unique-2-0-5"}]},{title:"Subsection 2-1",key:"unique-key-2-1",childItems:[{title:"Item 2-1-0",key:"unique-2-1-0"},{title:"Item 2-1-1",key:"unique-2-1-1"},{title:"Item 2-1-2",key:"unique-2-1-2"},{title:"Item 2-1-3",key:"unique-2-1-3"},{title:"Item 2-1-4",key:"unique-2-1-4"},{title:"Item 2-1-5",key:"unique-2-1-5"}]}]}];t.default=i},1803:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return p}));var i=n(18),a=n.n(i),u=n(24),c=n.n(u),l=(n(0),n(338)),r=n(1114),o=n(1662),s=n.n(o),d=["components"],m={};function p(e){var t=e.components,n=c()(e,d);return Object(l.mdx)("wrapper",a()({},m,n,{components:t,mdxType:"MDXLayout"}),Object(l.mdx)(r.a,{mdxType:"Badge"}),Object(l.mdx)("h1",{id:"terra-infinitelist---subsections"},"Terra InfiniteList - Subsections"),Object(l.mdx)("p",null,"To achieve sections within the InfiniteList the only supported implementation is directly consuming the static variant of the ",Object(l.mdx)("inlineCode",{parentName:"p"},"SectionHeader")," and ",Object(l.mdx)("inlineCode",{parentName:"p"},"SubsectionHeader")," component. Expand/collapse functionality is not supported within the infinite list. "),Object(l.mdx)("h2",{id:"map-section-structure"},"Map Section Structure"),Object(l.mdx)("p",null,"So in our first step a ",Object(l.mdx)("inlineCode",{parentName:"p"},"SectionHeader")," needs to be created for each associated section. We'll add it to the initialization of an array that will be expanded in the following steps."),Object(l.mdx)("pre",null,Object(l.mdx)("code",{parentName:"pre",className:"language-jsx"},"  const createSection = (sectionData) => {\n    const section = [\n      <SectionHeader\n        key={sectionData.key}\n        title={sectionData.title}\n      />,\n    ];\n    return section;\n  };\n")),Object(l.mdx)("p",null,"Next we'll create an array with the first item being our section header, and then loop through the associated child sub sections for the section appending them to the initial array."),Object(l.mdx)("pre",null,Object(l.mdx)("code",{parentName:"pre",className:"language-jsx"},"  const createSection = (sectionData) => {\n    const section = [\n      <SectionHeader\n        key={sectionData.key}\n        title={sectionData.title}\n      />,\n    ];\n    sectionData.childItems.forEach(childItem => section.push(createSection(childItem)));\n    return section;\n  };\n")),Object(l.mdx)("h2",{id:"map-subsection-structure"},"Map Subsection Structure"),Object(l.mdx)("p",null,"So in our first step a ",Object(l.mdx)("inlineCode",{parentName:"p"},"SubsectionHeader")," needs to be created for each associated section. We'll add it to the initialization of an array that will be expanded in following steps."),Object(l.mdx)("pre",null,Object(l.mdx)("code",{parentName:"pre",className:"language-jsx"},"const createSubSection = (subsectionData) => {\n  const section = [\n    <SubsectionHeader\n      key={subsectionData.key}\n      title={subsectionData.title}\n    />,\n  ];\n  return section;\n};\n")),Object(l.mdx)("p",null,"Next we'll create an array with the first item being our subsection header, and then loop through the associated child items for the section appending them to the initial array."),Object(l.mdx)("pre",null,Object(l.mdx)("code",{parentName:"pre",className:"language-jsx"},"const createSubSection = (subsectionData) => {\n  const section = [\n    <SubsectionHeader\n      key={subsectionData.key}\n      title={subsectionData.title}\n    />,\n  ];\n  subsectionData.childItems.forEach(childItem => section.push(createListItem(childItem)));\n  return section;\n};\n")),Object(l.mdx)("h2",{id:"unpack-data"},"Unpack Data"),Object(l.mdx)("p",null,"We can then implement the unpack of our data into our list items."),Object(l.mdx)("pre",null,Object(l.mdx)("code",{parentName:"pre",className:"language-jsx"},"const createListItem = itemData => (\n  <Item key={itemData.key}>\n    <Placeholder title={itemData.title} />\n  </Item>\n);\n\nconst createSections = data => data.map(section => createSection(section));\n")),Object(l.mdx)("p",null,"Then we can implement a method to loop through our data and create the section with our methods and call it from our render method."),Object(l.mdx)("pre",null,Object(l.mdx)("code",{parentName:"pre",className:"language-jsx"},'const InfiniteListSection = () => (\n  <MyExampleContainer>\n    <InfiniteList\n      dividerStyle="standard"\n      isFinishedLoading\n    >\n      {createSections(mockData)}\n    </InfiniteList>\n  </MyExampleContainer>\n);\n')),Object(l.mdx)("p",null,"Using these steps we get the following example:"),Object(l.mdx)("h2",{id:"example"},"Example"),Object(l.mdx)(s.a,{title:"Sections Header Infinite List",mdxType:"InfiniteListSubsection"}))}p.isMDXComponent=!0},989:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=l(n(0)),a=l(n(2)),u=l(n(5)),c=l(n(990));function l(e){return e&&e.__esModule?e:{default:e}}var r=u.default.bind(c.default),o={name:a.default.string.isRequired,src:a.default.string,url:a.default.string,version:a.default.string.isRequired},s=function(e){var t=e.src,n=e.name,a=e.url,u=e.version,c=i.default.createElement("a",{className:r("badge"),href:a||"https://www.npmjs.org/package/".concat(n,"/v/").concat(u)},i.default.createElement("span",{className:r("badge-name")},a?"package":"npm"),i.default.createElement("span",{className:r("badge-version")},"v".concat(u))),l=t?i.default.createElement("a",{className:r("badge"),href:t},i.default.createElement("span",{className:r("badge-name")},"github"),i.default.createElement("span",{className:r("badge-version")},"source")):void 0;return i.default.createElement("div",{className:r("badge-container")},c,l)};s.propTypes=o;var d=s;t.default=d},990:function(e,t,n){"use strict";n.r(t),t.default={badge:"Badges-module__badge___1ATf2","badge-container":"Badges-module__badge-container___5v0AK","badge-name":"Badges-module__badge-name___1rRv5","badge-version":"Badges-module__badge-version___2Cim-"}}}]);